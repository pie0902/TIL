# 동시성 제어
## 동시성 제어란?
동시성 제어(Concurrency Control)란 여러 사용자 또는 프로세스가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 유지하기 위해 사용되는 기술과 방법을 말한다.
## 동시성 제어의 목적
1. 데이터 일관성 유지: 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 일관된 데이터를 읽고 쓸 수 있도록 보장한다.
2. 격리성 보장: 한 트랜잭션의 중간 결과가 다른 트랜잭션에 영향을 미치지 않도록 트랜잭션 간의 격리성을 제공한다.
3. 병행성 향상: 동시에 실행 가능한 트랜잭션들을 최대한 병행 처리하여 시스템의 성능을 향상시킨다.
## 동시성 제어의 중요성 예시
1. 경쟁 상태(Race Condition)
   * 한정판 신발의 마지막 한 켤레를 두 사람이 동시 주문 시, 시스템 혼란으로 재고가 '-1'이 되는 비현실적 결과 발생.
2. 교착 상태(Dead Lock)
   * 서로의 작업 완료를 기다리는 두 프로세스가 영원히 멈춰 서면서 시스템 성능 저하 및 처리 정지.
3. 데이터 손상(Data Corruption)
   * 사용자 계좌의 동시 인출/입금 처리로 잔액이 부정확하게 되어 금융 혼란 유발.
<details>
<summary>예시 자세히 보기</summary>

#### 1. Race Condition
1. 시스템 제약 사항:
   * ex)매장 웹사이트 시스템은 한 번에 하나의 주문만 처리 가능
2. 문제 상황:
   * A와 B 두 사람이 동시에 재고가 1개 남은 신발을 주문
   * 시스템은 두 주문의 선후 관계를 정확히 인식하지 못함
3. 문제 발생:
   * 시스템이 두 주문을 모두 수락하는 것처럼 동작 (경쟁 상태 발생)
   * 두 주문이 동시에 처리되려고 하면서 재고 관리에 문제 발생
   * 재고가 '-1'이 되는 등의 비정상적인 상황 초래
4. 기대되는 동작:
   * 실제로는 한 켤레의 신발만 존재하므로, 한 사람에게만 판매되어야 함
#### 2.Dead Lock
1. 시스템 환경:
   * 온라인 쇼핑몰 시스템에서 두 개의 프로세스 A와 B가 동작 중
   * 프로세스 A는 '상품 정보 업데이트' 작업을 수행
   * 프로세스 B는 '재고 수량 업데이트' 작업을 수행
2. 문제 상황:
   * 프로세스 A는 '상품 정보 업데이트'를 위해 '상품 테이블'에 대한 잠금을 획득
   * 프로세스 B는 '재고 수량 업데이트'를 위해 '재고 테이블'에 대한 잠금을 획득
   * 프로세스 A는 작업을 완료하기 위해 '재고 테이블'에 대한 잠금을 요청
   * 프로세스 B는 작업을 완료하기 위해 '상품 테이블'에 대한 잠금을 요청
3. 교착 상태 발생:
   * 프로세스 A는 '재고 테이블' 잠금을 기다리며 대기
   * 프로세스 B는 '상품 테이블' 잠금을 기다리며 대기
   * 두 프로세스는 서로가 보유한 잠금을 요청하며 무한히 대기하는 상황 발생
4. 시스템 영향:
   * 교착 상태로 인해 프로세스 A와 B는 무한 대기 상태에 빠짐 
   * 시스템 자원이 점유된 채로 해제되지 않아 시스템 전체의 성능 저하 발생
   * 새로운 요청이 들어와도 처리할 수 없는 상태가 지속
     데이터 손상(Data Corruption) 사례:
#### 3.Data Corruption
1. 시스템 환경:
   * 온라인 은행 시스템에서 여러 개의 스레드가 동시에 동작 
   * 각 스레드는 사용자의 계좌 잔액을 업데이트하는 작업을 수행
2. 문제 상황:
   * 사용자 A의 계좌 잔액이 100만원이라고 가정 
   * 스레드 1이 사용자 A의 계좌에서 50만원을 인출하는 작업을 수행 
   * 동시에 스레드 2가 사용자 A의 계좌에 30만원을 입금하는 작업을 수행 
   * 두 스레드가 동시에 사용자 A의 계좌 잔액을 읽어와 연산을 수행
3. 데이터 손상 발생:
   * 스레드 1이 잔액을 읽어온 후 50만원을 차감하여 50만원을 저장 
   * 스레드 2가 잔액을 읽어온 후 30만원을 추가하여 130만원을 저장 
   * 두 스레드가 동시에 작업을 수행하여 예상치 못한 결과 발생 
   * 사용자 A의 계좌 잔액이 80만원이 되어야 하지만, 130만원으로 잘못 저장됨
4. 시스템 영향:
   * 사용자 A의 계좌 잔액에 대한 데이터 무결성이 훼손됨 
   * 은행 시스템의 신뢰성과 정확성이 감소 
   * 사용자의 자금 관리에 혼란을 초래할 수 있음
</details>

## 트랜잭션 격리 레벨 (MySQL 기준)
1. READ UNCOMMITTED
   * 커밋되지 않은 내용도 다른 트랜잭션에서 읽기 가능
2. READ COMMITTED
   * 커밋된 내용만 다른 트랜잭션에서 읽기 가능 
   * 동일 트랜잭션 내에서 조회 결과가 달라질 수 있음
3. REPEATABLE READ (MySQL 기본값)
   * 동일 트랜잭션 내에서 일관된 조회 결과 보장 
   * MySQL의 갭 락과 트랜잭션 ID 메커니즘으로 인해 Phantom Read 발생 확률 낮음
4. SERIALIZABLE
   * 가장 엄격한 격리 수준 
   * 동시 접근이 완전히 차단되어 직렬화된 실행 보장
   
**주의: 트랜잭션 격리 레벨은 DBMS마다 다를 수 있으므로 해당 DBMS의 문서를 참조해야 함**
## 동시성 제어 방법
### 락(Lock)의 종류와 특징
1. 비관적 락(Pessimistic Lock)
   * 다른 트랜잭션의 읽기(Shared Lock)나 쓰기(Exclusive Lock) 접근을 제한
   * 빠르게 락을 구현해야 할 때 사용
2. 낙관적 락(Optimistic Lock)
   * 버전 컬럼을 추가하여 버전 불일치 시 업데이트 제한
   * 트랜잭션을 사용하지 않아 성능은 좋으나, 충돌 가능성 존재
   * 충돌 발생 시 복구가 어려움
3. 분산 락(Distributed Lock)
   * 주로 Redis를 활용하여 구현
   * Redis를 사용하는 이유:
     1. 메모리 DB로 RDBMS 대비 매우 빠름
     2. 싱글 스레드로 동작하여 원자성(Atomic) 보장
   * MySQL로도 구현 가능하나 성능 이슈 존재
